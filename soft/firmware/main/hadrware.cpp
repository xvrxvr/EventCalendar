#include "hadrware.h"

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <utility>

#include <freertos/FreeRTOS.h>
#include <freertos/task.h>
#include <esp_system.h>
#include <driver/gpio.h>
#include <driver/spi_master.h>

#include <esp_adc/adc_oneshot.h>
#include <esp_adc/adc_cali.h>
#include <esp_adc/adc_cali_scheme.h>

#include <driver/i2c.h>
#include <driver/ledc.h>
#include <driver/uart.h>

#include <soc/spi_struct.h>
#include <soc/gpio_struct.h>
#include <hal/spi_ll.h>

#include "ILI9327_SHIELD.h"
#include "pins.h"

#define MY_SPI_HOST    HSPI_HOST

static spi_device_handle_t lcd_spi, sol_spi;
static adc_oneshot_unit_handle_t adc1_handle;

static TaskHandle_t sol_task_handle;

R503 fp_sensor;
LCD lcd;

static const i2c_port_t i2c_master_port = I2C_NUM_0;

#define _RS_COMMAND  gpio_set_level(PIN_NUM_LCD_RS, 0)
#define _RS_DATA gpio_set_level(PIN_NUM_LCD_RS, 1)
#define _LCD_IDLE _RS_DATA

struct CS_EN {
    CS_EN() {gpio_set_level(PIN_NUM_LCD_CS, 0);}
    ~CS_EN() {gpio_set_level(PIN_NUM_LCD_CS, 1); _LCD_IDLE;}
};

struct LCDAccess {
    static int lock_count;
    LCDAccess() {if (!lock_count++) spi_device_acquire_bus(lcd_spi, portMAX_DELAY);}
    ~LCDAccess() {if (!--lock_count) spi_device_release_bus(lcd_spi);}
};

int LCDAccess::lock_count;

#define delay(v) vTaskDelay((v)/portTICK_PERIOD_MS ? (v)/portTICK_PERIOD_MS : 1)

static void sol_task(void*);

inline void LCD::write_lcd(uint8_t d)
{
    spi_transaction_t t{};

    t.length=8;
    t.tx_data[0]=d;
    t.flags = SPI_TRANS_USE_TXDATA;

    ESP_ERROR_CHECK(spi_device_polling_transmit(lcd_spi, &t));
}

#define LCD_HW SPI2
inline void write_lcd_fast(uint8_t data)
{
    LCD_HW.slave.trans_done = 0;
    LCD_HW.data_buf[0] = data;
    LCD_HW.cmd.usr = 1;
    while(!LCD_HW.slave.trans_done) {;}

    GPIO.out_w1tc = 1 << PIN_NUM_LCD_WR;
    GPIO.out_w1ts = 1 << PIN_NUM_LCD_WR;
}

inline void LCD::_WRITE_DATA(uint8_t d)
{
    write_lcd(d);
    gpio_set_level(PIN_NUM_LCD_WR, 0);
    gpio_set_level(PIN_NUM_LCD_WR, 1);
}

inline void _WRITE_DATA_FAST(uint8_t d)
{
    write_lcd_fast(d);
}

inline void write_sol(uint8_t data)
{
    spi_transaction_t t{};

    t.length=8;
    t.tx_data[0]=data;
    t.flags = SPI_TRANS_USE_TXDATA;

    ESP_ERROR_CHECK(spi_device_polling_transmit(sol_spi, &t));
}


/* Internal function writes an 8 bit command byte to the display */
inline void LCD::_WriteCommand(uint8_t command)
{
	_RS_COMMAND;
	_WRITE_DATA(command);
}



/* Internal function writes an 8 bit data parameter byte to the display */
inline void _WriteData(uint8_t data)
{
	_RS_DATA;
	_WRITE_DATA_FAST(data);
}


/* Resets the interface */
void LCD::DReset(void)
{
	CS_EN cs_en;
	
	_WriteCommand(REG_RESET); //Soft reset
    delay(200);
}

// Writes the initial setting to the screen. Settings are taken from the ILI9325 application note.
void LCD::init_screen(void)
{
	DReset();	

    LCDAccess lcd_access;
    CS_EN cs_en;
	
	_WriteCommand(REG_DISPOFF);
	_WriteCommand(REG_EXITSLEEP);
	delay(120); //Must wait 120ms after exiting sleep 
	_WriteCommand(REG_CMDPROTECT);
	_WriteData(0x00);
	_WriteCommand(REG_DISPTIMING);
	_WriteData(0x10);
	_WriteData(0x10);
	_WriteData(0x02);
	_WriteData(0x02);
	_WriteCommand(REG_PANELDRIVE);
	_WriteData(0x00);
	_WriteData(0x35);
	_WriteData(0x00);
	_WriteData(0x00);
	_WriteData(0x01);
	_WriteData(0x02);
	_WriteCommand(REG_FRAMERATE);
	_WriteData(0x04);
	_WriteCommand(REG_PWRNORMMODE);
	_WriteData(0x01);
	_WriteData(0x04);
	_WriteCommand(REG_3GAMMA);
	_WriteData(0x80);
//	_WriteCommand(REG_ADDRMODE);
//	_WriteData(0x48);
	_WriteCommand(REG_PIXELFORMAT);
	_WriteData(0x55);
	_WriteCommand(REG_COLADDR);
	_WriteData(0x00);
	_WriteData(0x00);
	_WriteData(0x00);
	_WriteData(0xEF);
	_WriteCommand(REG_PAGEADDR);
	_WriteData(0x00);
	_WriteData(0x00);
	_WriteData(0x01);
	_WriteData(0x8F);
	_WriteCommand(REG_PARAREA);
	_WriteData(0x00);
	_WriteData(0x00);
	_WriteData(0x01);
	_WriteData(0x8F);
	_WriteCommand(REG_DISPON);
}

/* Places the screen in to or out of sleep mode where:
	mode is the required state. Valid values area
		true (screen will enter sleep state)
		false (screen will wake from sleep state)
*/
void LCD::DSleep(bool mode)
{
    {
        CS_EN cs_en;
    	
    	if(mode)
    	{
    		_WriteCommand(REG_ENTERSLEEP);
    	}
    	else
    	{
    		_WriteCommand(REG_EXITSLEEP);
    	}
    }
	delay(120);
} 
	



/* Turn the screen on or off where:
	mode is the required state. Valid values are
		ON (screen on)
		OFF (screen off)
*/
void LCD::DScreen(bool mode)
{
    CS_EN cs_en;
	
	if(mode)
		_WriteCommand(REG_DISPON);	//Screen on
	else
		_WriteCommand(REG_DISPOFF);  //Screen off
}




/* Sets the screen orientation and write direction where:
	mode is the direction, orientation to set the screen to. Valid vales are:
		SCREEN_NORMAL 		(Default)
		SCREEN_R90 			Screen is rotated 90o		
		SCREEN_R180 		Screen is rotated 180o
		SCREEN_R270 		Screen is rotated 270o		
*/
void LCD::DFlip(uint8_t mode)
{
	_FlipMode = mode;
	_res_x = RES_X;
	_res_y = RES_Y;
    CS_EN cs_en;
	switch(mode)
	{
		case(SCREEN_NORMAL): LCD_CtrlWrite_ILI9327(REG_ADDRMODE, 0b00001000); return;
		case(SCREEN_R90):	 LCD_CtrlWrite_ILI9327(REG_ADDRMODE, 0b10101000); break;
		case(SCREEN_R180):	 LCD_CtrlWrite_ILI9327(REG_ADDRMODE, 0b11001000); return;
		case(SCREEN_R270):	 LCD_CtrlWrite_ILI9327(REG_ADDRMODE, 0b00101000); break;	
	}
   	_res_x = RES_Y;
   	_res_y = RES_X;
}

/* Draws a solid rectangle to the using the current foreground colour where:
	x1 is the x coordinate of the top left corner of the rectangle.
	y1 is the y coordinate of the top left corner of the rectangle.
	x2 is the x coordinate of the bottom right corner of the rectangle.
	y2 is the y coordinate of the bottom right corner of the rectangle.
*/
void LCD::DRect(int16_t x1, int16_t y1, int16_t x2, int16_t y2, uint16_t color)
{
    LCDAccess lcd;
    CS_EN cs_en;
    
    _SetWriteArea(x1, y1, x2, y2);
    _WriteCommand(REG_WRITEMEM); //Write to RAM

    uint32_t total = (x2-x1+1)*(y2-y1+1);
    uint8_t col1 = color >> 8;
    uint8_t col2 = color & 0xFF;
    while(total--)
    {
        _WriteData(col2); 
        _WriteData(col1); 
    }
}

#define RNG(var, limit) if (var < 0) var = 0; else if (var >= limit) var = limit-1
void LCD::_SetWriteAreaDelta(int16_t& X1, int16_t& Y1, int16_t dx, int16_t dy)
{
    RNG(X1, _res_x);
    RNG(Y1, _res_y);
    int16_t X2 = X1 + dx - 1;
    int16_t Y2 = Y1 + dy - 1;
    _SetWriteArea(X1, Y1, X2, Y2);
}

void LCD::_SetWriteArea(int16_t& X1, int16_t& Y1, int16_t& X2, int16_t& Y2)
{
	//Make sure none of the area to write to is outside the display area. If so then crop it
    RNG(X1, _res_x);
    RNG(X2, _res_x);
    RNG(Y1, _res_y);
    RNG(Y2, _res_y);
#undef RNG
    if (X1 > X2) std::swap(X1, X2);
    if (Y1 > Y2) std::swap(Y1, Y2);

    uint16_t x1 = X1, x2 = X2, y1 = Y1, y2= Y2;

	//Adjust screen offset depending or orientation
	switch(_FlipMode)
	{
		case(SCREEN_NORMAL): break;
		case(SCREEN_R270): std::swap(x1, y1); std::swap(x2, y2); break;
			
		case(SCREEN_R90): std::swap(x1, y1); std::swap(x2, y2); break;
//			y1 += 32;
//			y2 += 32;
			break;
			
		case(SCREEN_R180):
//			x1 += 32;
//			x2 += 32;
			break;
	}
    LCDAccess lcd_access;
	
	//Set the memory write window
	_WriteCommand(REG_COLADDR);
	_WriteData(y1>>8);
	_WriteData(y1);
	_WriteData(y2>>8);
	_WriteData(y2);
	_WriteCommand(REG_PAGEADDR);
	_WriteData(x1>>8);
	_WriteData(x1);
	_WriteData(x2>>8);
	_WriteData(x2);
}



/* Internal function that writes 16 bits of data to one of the displays registers */
void LCD::LCD_CtrlWrite_ILI9327(uint8_t command, uint8_t data)
{
    LCDAccess lcd_access;
	_WriteCommand(command);
	_WriteData(data);
}

static const uint8_t font[] = {
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x7e,0x81,0xa5,0x81,0x81,0xbd,0x99,0x81,0x81,0x7e,0x00,0x00,0x00,0x00,
    0x00,0x00,0x7e,0xff,0xdb,0xff,0xff,0xc3,0xe7,0xff,0xff,0x7e,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x6c,0xfe,0xfe,0xfe,0xfe,0x7c,0x38,0x10,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x10,0x38,0x7c,0xfe,0x7c,0x38,0x10,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x18,0x3c,0x3c,0xe7,0xe7,0xe7,0x99,0x18,0x3c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x18,0x3c,0x7e,0xff,0xff,0x7e,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x3c,0x3c,0x18,0x00,0x00,0x00,0x00,0x00,0x00,
    0xff,0xff,0xff,0xff,0xff,0xff,0xe7,0xc3,0xc3,0xe7,0xff,0xff,0xff,0xff,0xff,0xff,
    0x00,0x00,0x00,0x00,0x00,0x3c,0x66,0x42,0x42,0x66,0x3c,0x00,0x00,0x00,0x00,0x00,
    0xff,0xff,0xff,0xff,0xff,0xc3,0x99,0xbd,0xbd,0x99,0xc3,0xff,0xff,0xff,0xff,0xff,
    0x00,0x00,0x1e,0x0e,0x1a,0x32,0x78,0xcc,0xcc,0xcc,0xcc,0x78,0x00,0x00,0x00,0x00,
    0x00,0x00,0x3c,0x66,0x66,0x66,0x66,0x3c,0x18,0x7e,0x18,0x18,0x00,0x00,0x00,0x00,
    0x00,0x00,0x3f,0x33,0x3f,0x30,0x30,0x30,0x30,0x70,0xf0,0xe0,0x00,0x00,0x00,0x00,
    0x00,0x00,0x7f,0x63,0x7f,0x63,0x63,0x63,0x63,0x67,0xe7,0xe6,0xc0,0x00,0x00,0x00,
    0x00,0x00,0x00,0x18,0x18,0xdb,0x3c,0xe7,0x3c,0xdb,0x18,0x18,0x00,0x00,0x00,0x00,
    0x00,0x80,0xc0,0xe0,0xf0,0xf8,0xfe,0xf8,0xf0,0xe0,0xc0,0x80,0x00,0x00,0x00,0x00,
    0x00,0x02,0x06,0x0e,0x1e,0x3e,0xfe,0x3e,0x1e,0x0e,0x06,0x02,0x00,0x00,0x00,0x00,
    0x00,0x00,0x18,0x3c,0x7e,0x18,0x18,0x18,0x18,0x7e,0x3c,0x18,0x00,0x00,0x00,0x00,
    0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x66,0x66,0x00,0x00,0x00,0x00,
    0x00,0x00,0x7f,0xdb,0xdb,0xdb,0x7b,0x1b,0x1b,0x1b,0x1b,0x1b,0x00,0x00,0x00,0x00,
    0x00,0x7c,0xc6,0x60,0x38,0x6c,0xc6,0xc6,0x6c,0x38,0x0c,0xc6,0x7c,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0xfe,0xfe,0xfe,0x00,0x00,0x00,0x00,
    0x00,0x00,0x18,0x3c,0x7e,0x18,0x18,0x18,0x18,0x7e,0x3c,0x18,0x7e,0x00,0x00,0x00,
    0x00,0x00,0x18,0x3c,0x7e,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,
    0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x7e,0x3c,0x18,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x18,0x0c,0xfe,0x0c,0x18,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x30,0x60,0xfe,0x60,0x30,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xc0,0xc0,0xc0,0xc0,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x28,0x6c,0xfe,0x6c,0x28,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x10,0x38,0x38,0x7c,0x7c,0xfe,0xfe,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0xfe,0xfe,0x7c,0x7c,0x38,0x38,0x10,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x18,0x3c,0x3c,0x3c,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00,
    0x00,0x66,0x66,0x66,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x6c,0x6c,0xfe,0x6c,0x6c,0x6c,0xfe,0x6c,0x6c,0x00,0x00,0x00,0x00,
    0x18,0x18,0x7c,0xc6,0xc2,0xc0,0x7c,0x06,0x86,0xc6,0x7c,0x18,0x18,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0xc2,0xc6,0x0c,0x18,0x30,0x60,0xc6,0x86,0x00,0x00,0x00,0x00,
    0x00,0x00,0x38,0x6c,0x6c,0x38,0x76,0xdc,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
    0x00,0x30,0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x0c,0x18,0x30,0x30,0x30,0x30,0x30,0x30,0x18,0x0c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x30,0x18,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x18,0x30,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x66,0x3c,0xff,0x3c,0x66,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x7e,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x02,0x06,0x0c,0x18,0x30,0x60,0xc0,0x80,0x00,0x00,0x00,0x00,
    0x00,0x00,0x7c,0xc6,0xc6,0xce,0xd6,0xd6,0xe6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x18,0x38,0x78,0x18,0x18,0x18,0x18,0x18,0x18,0x7e,0x00,0x00,0x00,0x00,
    0x00,0x00,0x7c,0xc6,0x06,0x0c,0x18,0x30,0x60,0xc0,0xc6,0xfe,0x00,0x00,0x00,0x00,
    0x00,0x00,0x7c,0xc6,0x06,0x06,0x3c,0x06,0x06,0x06,0xc6,0x7c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x0c,0x1c,0x3c,0x6c,0xcc,0xfe,0x0c,0x0c,0x0c,0x1e,0x00,0x00,0x00,0x00,
    0x00,0x00,0xfe,0xc0,0xc0,0xc0,0xfc,0x0e,0x06,0x06,0xc6,0x7c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x38,0x60,0xc0,0xc0,0xfc,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
    0x00,0x00,0xfe,0xc6,0x06,0x06,0x0c,0x18,0x30,0x30,0x30,0x30,0x00,0x00,0x00,0x00,
    0x00,0x00,0x7c,0xc6,0xc6,0xc6,0x7c,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x7c,0xc6,0xc6,0xc6,0x7e,0x06,0x06,0x06,0x0c,0x78,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x30,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x06,0x0c,0x18,0x30,0x60,0x30,0x18,0x0c,0x06,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x00,0x00,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x60,0x30,0x18,0x0c,0x06,0x0c,0x18,0x30,0x60,0x00,0x00,0x00,0x00,
    0x00,0x00,0x7c,0xc6,0xc6,0x0c,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x7c,0xc6,0xc6,0xde,0xde,0xde,0xdc,0xc0,0x7c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x10,0x38,0x6c,0xc6,0xc6,0xfe,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
    0x00,0x00,0xfc,0x66,0x66,0x66,0x7c,0x66,0x66,0x66,0x66,0xfc,0x00,0x00,0x00,0x00,
    0x00,0x00,0x3c,0x66,0xc2,0xc0,0xc0,0xc0,0xc0,0xc2,0x66,0x3c,0x00,0x00,0x00,0x00,
    0x00,0x00,0xf8,0x6c,0x66,0x66,0x66,0x66,0x66,0x66,0x6c,0xf8,0x00,0x00,0x00,0x00,
    0x00,0x00,0xfe,0x66,0x62,0x68,0x78,0x68,0x60,0x62,0x66,0xfe,0x00,0x00,0x00,0x00,
    0x00,0x00,0xfe,0x66,0x62,0x68,0x78,0x68,0x60,0x60,0x60,0xf0,0x00,0x00,0x00,0x00,
    0x00,0x00,0x3c,0x66,0xc2,0xc0,0xc0,0xde,0xc6,0xc6,0x66,0x3a,0x00,0x00,0x00,0x00,
    0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xfe,0xc6,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
    0x00,0x00,0x3c,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x1e,0x0c,0x0c,0x0c,0x0c,0x0c,0xcc,0xcc,0xcc,0x78,0x00,0x00,0x00,0x00,
    0x00,0x00,0xe6,0x66,0x6c,0x6c,0x78,0x78,0x6c,0x66,0x66,0xe6,0x00,0x00,0x00,0x00,
    0x00,0x00,0xf0,0x60,0x60,0x60,0x60,0x60,0x60,0x62,0x66,0xfe,0x00,0x00,0x00,0x00,
    0x00,0x00,0xc6,0xee,0xfe,0xfe,0xd6,0xc6,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
    0x00,0x00,0xc6,0xe6,0xf6,0xfe,0xde,0xce,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
    0x00,0x00,0x38,0x6c,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x6c,0x38,0x00,0x00,0x00,0x00,
    0x00,0x00,0xfc,0x66,0x66,0x66,0x7c,0x60,0x60,0x60,0x60,0xf0,0x00,0x00,0x00,0x00,
    0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xd6,0xde,0x7c,0x0c,0x0e,0x00,0x00,
    0x00,0x00,0xfc,0x66,0x66,0x66,0x7c,0x6c,0x66,0x66,0x66,0xe6,0x00,0x00,0x00,0x00,
    0x00,0x00,0x7c,0xc6,0xc6,0x60,0x38,0x0c,0x06,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x7e,0x7e,0x5a,0x18,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
    0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
    0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x6c,0x38,0x10,0x00,0x00,0x00,0x00,
    0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xd6,0xd6,0xfe,0x6c,0x6c,0x00,0x00,0x00,0x00,
    0x00,0x00,0xc6,0xc6,0x6c,0x6c,0x38,0x38,0x6c,0x6c,0xc6,0xc6,0x00,0x00,0x00,0x00,
    0x00,0x00,0x66,0x66,0x66,0x66,0x3c,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
    0x00,0x00,0xfe,0xc6,0x86,0x0c,0x18,0x30,0x60,0xc2,0xc6,0xfe,0x00,0x00,0x00,0x00,
    0x00,0x00,0x3c,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x80,0xc0,0xe0,0x70,0x38,0x1c,0x0e,0x06,0x02,0x00,0x00,0x00,0x00,
    0x00,0x00,0x3c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x0c,0x3c,0x00,0x00,0x00,0x00,
    0x10,0x38,0x6c,0xc6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,0x00,
    0x30,0x30,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x78,0x0c,0x7c,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
    0x00,0x00,0xe0,0x60,0x60,0x78,0x6c,0x66,0x66,0x66,0x66,0xdc,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x7c,0xc6,0xc0,0xc0,0xc0,0xc6,0x7c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x1c,0x0c,0x0c,0x3c,0x6c,0xcc,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x7c,0xc6,0xfe,0xc0,0xc0,0xc6,0x7c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x38,0x6c,0x64,0x60,0xf0,0x60,0x60,0x60,0x60,0xf0,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x76,0xcc,0xcc,0xcc,0xcc,0xcc,0x7c,0x0c,0xcc,0x78,0x00,
    0x00,0x00,0xe0,0x60,0x60,0x6c,0x76,0x66,0x66,0x66,0x66,0xe6,0x00,0x00,0x00,0x00,
    0x00,0x00,0x18,0x18,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x06,0x06,0x00,0x0e,0x06,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x3c,0x00,
    0x00,0x00,0xe0,0x60,0x60,0x66,0x6c,0x78,0x78,0x6c,0x66,0xe6,0x00,0x00,0x00,0x00,
    0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xec,0xfe,0xd6,0xd6,0xd6,0xd6,0xd6,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xdc,0x66,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xdc,0x66,0x66,0x66,0x66,0x66,0x7c,0x60,0x60,0xf0,0x00,
    0x00,0x00,0x00,0x00,0x00,0x76,0xcc,0xcc,0xcc,0xcc,0xcc,0x7c,0x0c,0x0c,0x1e,0x00,
    0x00,0x00,0x00,0x00,0x00,0xdc,0x76,0x62,0x60,0x60,0x60,0xf0,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x7c,0xc6,0x60,0x38,0x0c,0xc6,0x7c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x10,0x30,0x30,0xfc,0x30,0x30,0x30,0x30,0x36,0x1c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x3c,0x18,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xc6,0xc6,0xc6,0xd6,0xd6,0xfe,0x6c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xc6,0x6c,0x38,0x38,0x38,0x6c,0xc6,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7e,0x06,0x0c,0xf8,0x00,
    0x00,0x00,0x00,0x00,0x00,0xfe,0xcc,0x18,0x30,0x60,0xc6,0xfe,0x00,0x00,0x00,0x00,
    0x00,0x00,0x0e,0x18,0x18,0x18,0x70,0x18,0x18,0x18,0x18,0x0e,0x00,0x00,0x00,0x00,
    0x00,0x00,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,
    0x00,0x00,0x70,0x18,0x18,0x18,0x0e,0x18,0x18,0x18,0x18,0x70,0x00,0x00,0x00,0x00,
    0x00,0x00,0x76,0xdc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x10,0x38,0x6c,0xc6,0xc6,0xc6,0xfe,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x1e,0x36,0x66,0xc6,0xc6,0xfe,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
    0x00,0x00,0xfe,0x62,0x62,0x60,0x7c,0x66,0x66,0x66,0x66,0xfc,0x00,0x00,0x00,0x00,
    0x00,0x00,0xfc,0x66,0x66,0x66,0x7c,0x66,0x66,0x66,0x66,0xfc,0x00,0x00,0x00,0x00,
    0x00,0x00,0xfe,0x62,0x62,0x60,0x60,0x60,0x60,0x60,0x60,0xf0,0x00,0x00,0x00,0x00,
    0x00,0x00,0x1e,0x36,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0xff,0xc3,0x81,0x00,0x00,
    0x00,0x00,0xfe,0x66,0x62,0x68,0x78,0x68,0x60,0x62,0x66,0xfe,0x00,0x00,0x00,0x00,
    0x00,0x00,0xd6,0xd6,0x54,0x54,0x7c,0x7c,0x54,0xd6,0xd6,0xd6,0x00,0x00,0x00,0x00,
    0x00,0x00,0x7c,0xc6,0x06,0x06,0x3c,0x06,0x06,0x06,0xc6,0x7c,0x00,0x00,0x00,0x00,
    0x00,0x00,0xc6,0xc6,0xce,0xce,0xd6,0xe6,0xe6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
    0x38,0x38,0xc6,0xc6,0xce,0xce,0xd6,0xe6,0xe6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
    0x00,0x00,0xe6,0x66,0x6c,0x6c,0x78,0x78,0x6c,0x6c,0x66,0xe6,0x00,0x00,0x00,0x00,
    0x00,0x00,0x1e,0x36,0x66,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
    0x00,0x00,0xc6,0xee,0xfe,0xfe,0xd6,0xc6,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
    0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xfe,0xc6,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
    0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
    0x00,0x00,0xfe,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
    0x00,0x00,0xfc,0x66,0x66,0x66,0x7c,0x60,0x60,0x60,0x60,0xf0,0x00,0x00,0x00,0x00,
    0x00,0x00,0x3c,0x66,0xc2,0xc0,0xc0,0xc0,0xc0,0xc2,0x66,0x3c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x7e,0x5a,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
    0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0x7e,0x06,0x06,0xc6,0x7c,0x00,0x00,0x00,0x00,
    0x00,0x3c,0x18,0x7e,0xdb,0xdb,0xdb,0xdb,0xdb,0x7e,0x18,0x3c,0x00,0x00,0x00,0x00,
    0x00,0x00,0xc6,0xc6,0x6c,0x7c,0x38,0x38,0x7c,0x6c,0xc6,0xc6,0x00,0x00,0x00,0x00,
    0x00,0x00,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xfe,0x06,0x06,0x00,0x00,
    0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0x7e,0x06,0x06,0x06,0x06,0x00,0x00,0x00,0x00,
    0x00,0x00,0xdb,0xdb,0xdb,0xdb,0xdb,0xdb,0xdb,0xdb,0xdb,0xff,0x00,0x00,0x00,0x00,
    0x00,0x00,0xdb,0xdb,0xdb,0xdb,0xdb,0xdb,0xdb,0xdb,0xdb,0xff,0x03,0x03,0x00,0x00,
    0x00,0x00,0xf8,0xb0,0x30,0x30,0x3e,0x33,0x33,0x33,0x33,0x7e,0x00,0x00,0x00,0x00,
    0x00,0x00,0xc3,0xc3,0xc3,0xc3,0xf3,0xdb,0xdb,0xdb,0xdb,0xf3,0x00,0x00,0x00,0x00,
    0x00,0x00,0xf0,0x60,0x60,0x60,0x7c,0x66,0x66,0x66,0x66,0xfc,0x00,0x00,0x00,0x00,
    0x00,0x00,0x7c,0xc6,0x06,0x26,0x3e,0x26,0x06,0x06,0xc6,0x7c,0x00,0x00,0x00,0x00,
    0x00,0x00,0xce,0xdb,0xdb,0xdb,0xfb,0xdb,0xdb,0xdb,0xdb,0xce,0x00,0x00,0x00,0x00,
    0x00,0x00,0x3f,0x66,0x66,0x66,0x3e,0x3e,0x66,0x66,0x66,0xe7,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x78,0x0c,0x7c,0xcc,0xcc,0xcc,0x76,0x00,0x00,0x00,0x00,
    0x00,0x02,0x06,0x3c,0x60,0x60,0x7c,0x66,0x66,0x66,0x66,0x3c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xfc,0x66,0x66,0x7c,0x66,0x66,0xfc,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x7e,0x32,0x32,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x1e,0x36,0x36,0x66,0x66,0x66,0xff,0xc3,0xc3,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x7c,0xc6,0xfe,0xc0,0xc0,0xc6,0x7c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xd6,0xd6,0x54,0x7c,0x54,0xd6,0xd6,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x3c,0x66,0x06,0x0c,0x06,0x66,0x3c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xc6,0xc6,0xce,0xd6,0xe6,0xc6,0xc6,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x38,0x38,0xc6,0xc6,0xce,0xd6,0xe6,0xc6,0xc6,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xe6,0x6c,0x78,0x78,0x6c,0x66,0xe6,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x1e,0x36,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xc6,0xee,0xfe,0xfe,0xd6,0xd6,0xc6,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xc6,0xc6,0xc6,0xfe,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x7c,0xc6,0xc6,0xc6,0xc6,0xc6,0x7c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xfe,0xc6,0xc6,0xc6,0xc6,0xc6,0xc6,0x00,0x00,0x00,0x00,
    0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,0x11,0x44,
    0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,0x55,0xaa,
    0xdd,0x77,0xdd,0x77,0xdd,0x77,0xdd,0x77,0xdd,0x77,0xdd,0x77,0xdd,0x77,0xdd,0x77,
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xf8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
    0x18,0x18,0x18,0x18,0x18,0xf8,0x18,0xf8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
    0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xf6,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfe,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
    0x00,0x00,0x00,0x00,0x00,0xf8,0x18,0xf8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
    0x36,0x36,0x36,0x36,0x36,0xf6,0x06,0xf6,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
    0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
    0x00,0x00,0x00,0x00,0x00,0xfe,0x06,0xf6,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
    0x36,0x36,0x36,0x36,0x36,0xf6,0x06,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x18,0x18,0x18,0x18,0x18,0xf8,0x18,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf8,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x1f,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
    0x18,0x18,0x18,0x18,0x18,0x1f,0x18,0x1f,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
    0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x37,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
    0x36,0x36,0x36,0x36,0x36,0x37,0x30,0x3f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x3f,0x30,0x37,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
    0x36,0x36,0x36,0x36,0x36,0xf7,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xff,0x00,0xf7,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
    0x36,0x36,0x36,0x36,0x36,0x37,0x30,0x37,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
    0x00,0x00,0x00,0x00,0x00,0xff,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x36,0x36,0x36,0x36,0x36,0xf7,0x00,0xf7,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
    0x18,0x18,0x18,0x18,0x18,0xff,0x00,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xff,0x00,0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
    0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x3f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x18,0x18,0x18,0x18,0x18,0x1f,0x18,0x1f,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x1f,0x18,0x1f,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x3f,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
    0x36,0x36,0x36,0x36,0x36,0x36,0x36,0xff,0x36,0x36,0x36,0x36,0x36,0x36,0x36,0x36,
    0x18,0x18,0x18,0x18,0x18,0xff,0x18,0xff,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
    0x18,0x18,0x18,0x18,0x18,0x18,0x18,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1f,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
    0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,0xf0,
    0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,0x0f,
    0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xdc,0x66,0x66,0x66,0x66,0x66,0x7c,0x60,0x60,0xf0,0x00,
    0x00,0x00,0x00,0x00,0x00,0x7c,0xc6,0xc0,0xc0,0xc0,0xc6,0x7c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x7e,0x5a,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xc6,0xc6,0xc6,0xc6,0xc6,0x7e,0x06,0x06,0xc6,0x7c,0x00,
    0x00,0x00,0x00,0x00,0x3c,0x18,0x7e,0xdb,0xdb,0xdb,0xdb,0x7e,0x18,0x18,0x3c,0x00,
    0x00,0x00,0x00,0x00,0x00,0xc6,0x6c,0x38,0x38,0x38,0x6c,0xc6,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xcc,0xcc,0xcc,0xcc,0xcc,0xcc,0xfe,0x06,0x06,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xc6,0xc6,0xc6,0xc6,0x7e,0x06,0x06,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xd6,0xd6,0xd6,0xd6,0xd6,0xd6,0xfe,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xd6,0xd6,0xd6,0xd6,0xd6,0xd6,0xfe,0x03,0x03,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xf8,0xb0,0x30,0x3e,0x33,0x33,0x7e,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xc6,0xc6,0xc6,0xf6,0xde,0xde,0xf6,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xf0,0x60,0x60,0x7c,0x66,0x66,0xfc,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x3c,0x66,0x06,0x1e,0x06,0x66,0x3c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0xce,0xdb,0xdb,0xfb,0xdb,0xdb,0xce,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x7e,0xcc,0xcc,0xfc,0x6c,0xcc,0xce,0x00,0x00,0x00,0x00,
    0x6c,0x00,0xfe,0x66,0x62,0x68,0x78,0x68,0x60,0x62,0x66,0xfe,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x6c,0x00,0x7c,0xc6,0xfe,0xc0,0xc0,0xc6,0x7c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x7c,0xc6,0xc0,0xc8,0xf8,0xc8,0xc0,0xc0,0xc6,0x7c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x3c,0x66,0x60,0x78,0x60,0x66,0x3c,0x00,0x00,0x00,0x00,
    0x66,0x00,0x3c,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x28,0x28,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x3c,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x7e,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x76,0xdc,0x00,0x76,0xdc,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x38,0x6c,0x6c,0x38,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x01,0x03,0x02,0x06,0x04,0xcc,0x68,0x38,0x10,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x8b,0xcb,0xc8,0xa8,0xa8,0x98,0x98,0x88,0x88,0x00,0x00,0x00,0x00,
    0x00,0x70,0xd8,0x30,0x60,0xc8,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x3c,0x3c,0x3c,0x3c,0x3c,0x3c,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

inline int16_t midx(int syms_len)
{
    return (RES_X - syms_len*8) / 2;
}

void LCD::text(const char* text, int16_t x, int16_t y)
{
    LCDAccess lcd;
    CS_EN cs_en;

    uint8_t txt_len = strlen(text);
    if (x == -1) x = midx(txt_len);
    _SetWriteAreaDelta(x, y, txt_len<<3, 16);
    _WriteCommand(REG_WRITEMEM); //Write to RAM

    for(uint8_t scan_line=0; scan_line!=16; ++scan_line)
    {
        for(const char* t=text;; ++t)
        {
            uint8_t sym = *t;
            if (!sym) break;
            uint8_t bits = font[sym*16+scan_line];
            uint8_t cnt=8;
            do {
                if (bits&0x80) {_WriteData(fc2); _WriteData(fc1);}
                else {_WriteData(bc2); _WriteData(bc1);}
                bits <<= 1;
            } while (--cnt);
        }
    }
}

void LCD::text2(const char* text, int16_t x, int16_t y)
{
    LCDAccess lcd;
    CS_EN cs_en;

    uint8_t txt_len = strlen(text);
    if (x == -1) x = midx(txt_len*2);
    _SetWriteAreaDelta(x, y, txt_len<<4, 32);
    _WriteCommand(REG_WRITEMEM); //Write to RAM

    for(uint8_t scan_line=0; scan_line!=32; ++scan_line)
    {
        for(const char* t=text;; ++t)
        {
            uint8_t sym = *t;
            if (!sym) break;
            uint8_t bits = font[sym*16+(scan_line>>1)];
            uint8_t cnt=8;
            do {
                if (bits&0x80) {_WriteData(fc2); _WriteData(fc1); _WriteData(fc2); _WriteData(fc1);}
                else {_WriteData(bc2); _WriteData(bc1); _WriteData(bc2); _WriteData(bc1);}
                bits <<= 1;
            } while (--cnt);
        }
    }
}


#define _B(n) (1ull<<(n))

void hw_init()
{
    gpio_set_level(PIN_NUM_OE_SOL, 1);
    gpio_set_level(PIN_NUM_LCD_CS, 1);
    gpio_set_level(PIN_NUM_LCD_SW1, 1);
    gpio_set_level(PIN_NUM_LCD_SW2, 1);
    gpio_set_level(PIN_NUM_LCD_WR, 1);
    gpio_set_level(PIN_NUM_LCD_BL, 1);

    gpio_config_t gpio_cfg_out = {
        .pin_bit_mask = _B(PIN_NUM_OE_SOL)|_B(PIN_NUM_LCD_CS)|_B(PIN_NUM_LCD_BL)|_B(PIN_NUM_LCD_SW1)|_B(PIN_NUM_LCD_SW2)|_B(PIN_NUM_LCD_WR)|_B(PIN_NUM_LCD_RS),
        .mode = GPIO_MODE_OUTPUT,
        .pull_up_en = GPIO_PULLUP_DISABLE,
        .pull_down_en = GPIO_PULLDOWN_DISABLE,
        .intr_type = GPIO_INTR_DISABLE
    };
    ESP_ERROR_CHECK(gpio_config(&gpio_cfg_out));
    gpio_config_t gpio_cfg_in = {
        .pin_bit_mask = _B(PIN_NUM_FP_WAKEUP)|_B(PIN_NUM_DIPSW_BOOT)|_B(PIN_NUM_DIPSW_AUX),
        .mode = GPIO_MODE_INPUT,
        .pull_up_en = GPIO_PULLUP_ENABLE,
        .pull_down_en = GPIO_PULLDOWN_DISABLE,
        .intr_type = GPIO_INTR_DISABLE
    };
    ESP_ERROR_CHECK(gpio_config(&gpio_cfg_in));

    gpio_set_level(PIN_NUM_OE_SOL, 1);
    gpio_set_level(PIN_NUM_LCD_CS, 1);
    gpio_set_level(PIN_NUM_LCD_SW1, 1);
    gpio_set_level(PIN_NUM_LCD_SW2, 1);
    gpio_set_level(PIN_NUM_LCD_WR, 1);
    gpio_set_level(PIN_NUM_LCD_BL, 1);

    spi_bus_config_t buscfg={
        .mosi_io_num=PIN_NUM_MOSI,
        .miso_io_num=-1,
        .sclk_io_num=PIN_NUM_CLK,
        .quadwp_io_num=-1,
        .quadhd_io_num=-1,
        .max_transfer_sz=10
    };
    spi_device_interface_config_t lcd_devcfg={
        .mode=0,
        .clock_speed_hz=SPI_MASTER_FREQ_80M,
        .spics_io_num=PIN_NUM_CS_LCD,
        .flags = SPI_DEVICE_NO_DUMMY,
        .queue_size=1
    };
    spi_device_interface_config_t sol_devcfg={
        .mode=0,
        .clock_speed_hz=SPI_MASTER_FREQ_10M,
        .spics_io_num=PIN_NUM_CS_SOL,
        .queue_size=1
    };
    //Initialize the SPI bus
    ESP_ERROR_CHECK(spi_bus_initialize(MY_SPI_HOST, &buscfg, SPI_DMA_CH_AUTO));

    //Attach the LCD to the SPI bus
    ESP_ERROR_CHECK(spi_bus_add_device(MY_SPI_HOST, &lcd_devcfg, &lcd_spi));

    //Attach the Solenoids to the SPI bus
    ESP_ERROR_CHECK(spi_bus_add_device(MY_SPI_HOST, &sol_devcfg, &sol_spi));

    // Zero Solenoid register, then OE it
    write_sol(0);
    gpio_set_level(PIN_NUM_OE_SOL, 0);

    // ADC config
    adc_oneshot_unit_init_cfg_t init_config1 = {
        .unit_id = ADC_UNIT_1,
    };
    ESP_ERROR_CHECK(adc_oneshot_new_unit(&init_config1, &adc1_handle));

    adc_oneshot_chan_cfg_t config = {
        .atten = ADC_ATTEN_DB_11,
        .bitwidth = ADC_BITWIDTH_DEFAULT,
    };
    ESP_ERROR_CHECK(adc_oneshot_config_channel(adc1_handle, ADC_Y_PLUS, &config));
    ESP_ERROR_CHECK(adc_oneshot_config_channel(adc1_handle, ADC_X_MINUS, &config));

    // LCD
    delay(50);
    {
	    lcd.init_screen();
    	lcd.DFlip(LCD::SCREEN_MY);
    	lcd.DRect(0, 0, LCD::MAX, LCD::MAX, 0);
    }

    // Configure I2C
    i2c_port_t i2c_master_port = I2C_NUM_0;
    i2c_config_t conf = {
        .mode = I2C_MODE_MASTER,
        .sda_io_num = PIN_NUM_I2C_SDA,
        .scl_io_num = PIN_NUM_I2C_SCL,
        .sda_pullup_en = GPIO_PULLUP_DISABLE,
        .scl_pullup_en = GPIO_PULLUP_DISABLE,
        .master = {
            .clk_speed = 100'000
        }
    };

    i2c_param_config(i2c_master_port, &conf);

    ESP_ERROR_CHECK(i2c_driver_install(i2c_master_port, conf.mode, 0, 0, 0));

    ledc_timer_config_t ledc_timer = {
        .speed_mode       = LEDC_HIGH_SPEED_MODE,
        .duty_resolution  = LEDC_TIMER_13_BIT,
        .timer_num        = LEDC_TIMER_0,
        .freq_hz          = 5000,  // Set output frequency at 5 kHz
        .clk_cfg          = LEDC_AUTO_CLK
    };
    ESP_ERROR_CHECK(ledc_timer_config(&ledc_timer));

    // Prepare and then apply the LEDC PWM channel configuration
    ledc_channel_config_t ledc_channel = {
        .gpio_num       = PIN_NUM_LCD_BL,
        .speed_mode     = LEDC_HIGH_SPEED_MODE,
        .channel        = LEDC_CHANNEL_0,
        .intr_type      = LEDC_INTR_DISABLE,
        .timer_sel      = LEDC_TIMER_0,
        .duty           = (1<<13)-1,
        .hpoint         = 0
    };
    ESP_ERROR_CHECK(ledc_channel_config(&ledc_channel));

    const uart_port_t uart_num = UART_NUM_2;
    uart_config_t uart_config = {
        .baud_rate = 57600,
        .data_bits = UART_DATA_8_BITS,
        .parity = UART_PARITY_DISABLE,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
        .rx_flow_ctrl_thresh = 0,
        .source_clk = UART_SCLK_DEFAULT
    };
    // Configure UART parameters
    ESP_ERROR_CHECK(uart_param_config(uart_num, &uart_config));
    ESP_ERROR_CHECK(uart_set_pin(UART_NUM_2, PIN_NUM_FP_RXD, PIN_NUM_FP_TXD, -1, -1));

    ESP_ERROR_CHECK(uart_driver_install(UART_NUM_2, 2048, 0, 0, NULL, 0));

    xTaskCreate(sol_task, "Sol", 2048, NULL, tskIDLE_PRIORITY+1, &sol_task_handle);

    delay(150);
    auto err = fp_sensor.init();
    
    if (err != R503_SUCCESS)
    {
        printf("FP_sensor init error: %s\n", R503::errorMsg(err));
        abort();
    }
}


void sol_hit(int index)
{
    xTaskNotify(sol_task_handle, (index&7)+1, eSetValueWithOverwrite);
}

/*
    BL      - 5           LCD    TouchX TouchXInv TouchY  TouchYInv  TouchSence     TouchSence/Alt    Idle
    DB7/Y- (SW1) - 27    1/DB7     0      0         1/0     1/1          1/0             0             1/1
    DB6/X+ (SW2) - 26    1/DB6    1/1    1/0         0       0            0             1/0            1/1
    WR/Y+   - 21          WR      ADC    ADC         1       0            0           PullUP/Sence      1       -> 36 (SENSOR_VP)
    RS/X-   - 19          RS       0      1         ADC     ADC        PullUP/Sence      0              1       -> 39 (SENSOR_VN)
*/

enum TouchType {
    TT_LCD,
    TT_X,
    TT_XInv,
    TT_Y,
    TT_YInv,
    TT_Sence
};

enum TTSetup {
    TTS_SW1     = 0x01,
    TTS_SW2     = 0x02,
    TTS_WR_ADC  = 0x04,
    TTS_WR      = 0x08,
    TTS_RS_ADC  = 0x10,
    TTS_RS      = 0x20,
    TTS_DB6     = 0x40,   // Do not change value!
    TTS_DB7     = 0x80,   // Do not change value!
    TTS_RS_SNS  = 0x100
};

static const int tts_setup [] = {
    TTS_SW1 | TTS_SW2 | TTS_WR | TTS_RS,         // TT_LCD
    TTS_SW2 | TTS_DB6 | TTS_WR_ADC,              // TT_X
    TTS_SW2 | TTS_WR_ADC | TTS_RS,               // TT_XInv
    TTS_SW1 | TTS_WR | TTS_RS_ADC,               // TT_Y
    TTS_SW1 | TTS_DB7 | TTS_RS_ADC,              // TT_YInv
    TTS_SW1 | TTS_RS_SNS                         // TT_Sence
};

#define NOP() __asm volatile("nop")

static const int adc_reads = 10;

int touch_config(TouchType tt)
{
    int read_adc = -1;
    int setup = tts_setup[tt];
#define V(name) ((setup & TTS_##name) != 0)
    lcd.write_lcd(setup & 0xC0); // DB6 & DB7
    gpio_set_level(PIN_NUM_LCD_SW1, V(SW1));
    gpio_set_level(PIN_NUM_LCD_SW2, V(SW2));

    if (setup & TTS_WR_ADC) {gpio_set_direction(PIN_NUM_LCD_WR, GPIO_MODE_DISABLE); read_adc = ADC_Y_PLUS;}
    else {gpio_set_level(PIN_NUM_LCD_WR, V(WR)); gpio_set_direction(PIN_NUM_LCD_WR, GPIO_MODE_OUTPUT);}

    if (setup & TTS_RS_SNS) {gpio_set_direction(PIN_NUM_LCD_RS, GPIO_MODE_INPUT); gpio_set_pull_mode(PIN_NUM_LCD_RS, GPIO_PULLUP_ONLY); NOP(); NOP(); return gpio_get_level(PIN_NUM_LCD_RS);} else
    if (setup & TTS_RS_ADC) {gpio_set_pull_mode(PIN_NUM_LCD_RS, GPIO_FLOATING); gpio_set_direction(PIN_NUM_LCD_RS, GPIO_MODE_DISABLE); read_adc = ADC_X_MINUS;} 
    else {gpio_set_level(PIN_NUM_LCD_RS, V(RS)); gpio_set_direction(PIN_NUM_LCD_RS, GPIO_MODE_OUTPUT);}
#undef V

    if (read_adc != -1)
    {
        int result = 0;
        vTaskDelay(1);

        for(int i=0; i<adc_reads; ++i)
        {
            int value = 0;
            ESP_ERROR_CHECK(adc_oneshot_read(adc1_handle, (adc_channel_t)read_adc, &value));
            result += value;
        }
        return result / adc_reads;
    }

    return 0;
}

TouchConfig::TouchConfig() {x=y=-1; touched();}
TouchConfig::~TouchConfig() {touch_config(TT_LCD);}

constexpr int32_t mid_y = 2850;
constexpr int32_t min_y = 300;


bool TouchConfig::touched()
{
    int ts = 0;
    x=y=-1;
    for(int i=0; i<100; ++i)
    {
        ts <<= 2;
        ts |= touch_config(TT_Sence) ? 1 : 2;
        ts &= 0x3FF;
        if (ts == 0x111) return false;
        if (ts == 0x222)
        {
            x = touch_config(TT_X);
//            y = touch_config(TT_Y);
//            if (y < min_y) y = mid_y - touch_config(TT_YInv);
            y = touch_config(TT_YInv); // Inverted part has higher minimum value (about threshold - 240-250). Not-inverted has minimum of 78
            return true;
        }
    }
    printf("TouchConfig: Can't get Touch status for 100 samples!\n");
    return false;
}

void TouchConfig::wait_press()
{
    while(!touched())
    {
        touch_config(TT_LCD);
        delay(10);
    }
}

void TouchConfig::wait_release()
{
    while(touched())
    {
        touch_config(TT_LCD);
        delay(10);
    }
}

static void sol_task(void*)
{
    delay(10000);
    for(;;)
    {
        uint32_t index = ulTaskNotifyTake(pdTRUE, portMAX_DELAY); 
        if (index > 0 && index <= 8)
        {
            --index;

            write_sol(1<<index);
            delay(1000);
            write_sol(0);
            delay(10000);
        }
    }
}


#define I2C_MASTER_TIMEOUT   (1000/portTICK_PERIOD_MS)

int get_temperature()
{
    // Temperature
    int8_t data[2] = {0};
    ESP_ERROR_CHECK(i2c_master_read_from_device(i2c_master_port, 0x48, (uint8_t *)data, 2, I2C_MASTER_TIMEOUT));
    return data[0];
}


static uint8_t bcd2bin(uint8_t bcd)
{
    return (bcd >> 4) * 10 + (bcd & 0xF);
}

static uint8_t bin2bcd(uint8_t bin)
{
    return ((bin / 10) << 4) | (bin % 10);
}

bool RTC::read()
{
     uint8_t ptr=0;
     uint8_t data[8];

     ESP_ERROR_CHECK(i2c_master_write_read_device(i2c_master_port, 0xD0>>1, &ptr, 1, data, 8, I2C_MASTER_TIMEOUT));

     seconds = bcd2bin(data[0] & 0x7F);
     minutes = bcd2bin(data[1] & 0x7F);
     hours = bcd2bin(data[2] & 0x3F);
     day = data[3] & 7;
     date = bcd2bin(data[4] & 0x3F);
     month = bcd2bin(data[5] & 0x1F);
     year = bcd2bin(data[6]);

     return (data[0] & 0x80) == 0;
}

void RTC::write()
{
    uint8_t data[9];

    data[0] = 0;
    data[1] = bin2bcd( seconds) & 0x7F;
    data[2] = bin2bcd( minutes) & 0x7F;
    data[3] = (bin2bcd( hours  ) & 0x3F) | 0x40;
    data[4] = day & 7;
    data[5] = bin2bcd( date   ) & 0x3F;
    data[6] = bin2bcd( month  ) & 0x1F;
    data[7] = bin2bcd( year  );
    data[8] = 0;

    ESP_ERROR_CHECK(i2c_master_write_to_device(i2c_master_port, 0xD0>>1, data, 9, I2C_MASTER_TIMEOUT));
}

void RTC::start()
{
    uint8_t data[2];

    data[0] = 0;
    data[1] = 0;
    ESP_ERROR_CHECK(i2c_master_write_to_device(i2c_master_port, 0xD0>>1, data, 2, I2C_MASTER_TIMEOUT));
}

void RTC::read_ram(void* dst, uint8_t shift, uint8_t size)
{
     uint8_t ptr = 8 + shift;

     ESP_ERROR_CHECK(i2c_master_write_read_device(i2c_master_port, 0xD0>>1, &ptr, 1, (uint8_t*)dst, size, I2C_MASTER_TIMEOUT));
}

void RTC::write_ram(const void* src, uint8_t shift, uint8_t size)
{
    uint8_t ptr = 8 + shift;
    ESP_ERROR_CHECK(i2c_master_write_to_device(i2c_master_port, 0xD0>>1, &ptr, 1, I2C_MASTER_TIMEOUT));
    ESP_ERROR_CHECK(i2c_master_write_to_device(i2c_master_port, 0xD0>>1, (const uint8_t*)src, size, I2C_MASTER_TIMEOUT));
}

#define I2C_TRANS_BUF_MINIMUM_SIZE 128

static esp_err_t i2c_master_probe_to_device(i2c_port_t i2c_num, uint8_t device_address, TickType_t ticks_to_wait)
{
    esp_err_t err = ESP_OK;
    uint8_t buffer[I2C_TRANS_BUF_MINIMUM_SIZE] = { 0 };

    i2c_cmd_handle_t handle = i2c_cmd_link_create_static(buffer, sizeof(buffer));
    assert (handle != NULL);

    err = i2c_master_start(handle);
    if (err != ESP_OK) {
        goto end;
    }

    err = i2c_master_write_byte(handle, device_address << 1 | I2C_MASTER_WRITE, true);
    if (err != ESP_OK) {
        goto end;
    }

    i2c_master_stop(handle);
    err = i2c_master_cmd_begin(i2c_num, handle, ticks_to_wait);

end:
    i2c_cmd_link_delete_static(handle);
    return err;
}


// Page writes performed on page boundaries - page write will wrap around if address+size will cross 32 byte block
void EEPROM::write(uint16_t address, const void* data, uint8_t size)
{
    assert(size <= 32);
    poll4ready();
    uint8_t addr[2] = {uint8_t(address >> 8), uint8_t(address)}; 
    ESP_ERROR_CHECK(i2c_master_write_to_device(i2c_master_port, 0xA0>>1, addr, 2, I2C_MASTER_TIMEOUT));
    ESP_ERROR_CHECK(i2c_master_write_to_device(i2c_master_port, 0xA0>>1, (const uint8_t*)data, size, I2C_MASTER_TIMEOUT));        
}

void EEPROM::read(uint16_t address, void* data, uint8_t size)
{
    poll4ready();
    uint8_t addr[2] = {uint8_t(address >> 8), uint8_t(address)}; 
    ESP_ERROR_CHECK(i2c_master_write_read_device(i2c_master_port, 0xA0>>1, addr, 2, (uint8_t*)data, size, I2C_MASTER_TIMEOUT));
}

void EEPROM::poll4ready()
{
    while(i2c_master_probe_to_device(i2c_master_port, 0xA0>>1, I2C_MASTER_TIMEOUT)) {;}
}

void fade_out()
{
    ESP_ERROR_CHECK(ledc_set_fade_time_and_start(LEDC_HIGH_SPEED_MODE, LEDC_CHANNEL_0, 0, 1000, LEDC_FADE_WAIT_DONE));
}

void fade_in()
{
    ESP_ERROR_CHECK(ledc_set_fade_time_and_start(LEDC_HIGH_SPEED_MODE, LEDC_CHANNEL_0, 100, 1000, LEDC_FADE_WAIT_DONE));
}

bool test_wakeup() {return !gpio_get_level(PIN_NUM_FP_WAKEUP);}

#if 0
static esp_err_t destroy_my_pannel(esp_lcd_panel_handle_t h) {delete h; return ESP_OK;}

static esp_err_t mirror_my_pannel(esp_lcd_panel_t *panel, bool x_axis, bool y_axis)
{
    return ESP_OK;
}

static esp_err_t swap_my_pannel(esp_lcd_panel_t *panel, bool swap_axes)
{
    return ESP_OK;
}

static esp_err_t set_gap_my_pannel(esp_lcd_panel_t *panel, int x_gap, int y_gap)
{
    return ESP_OK;
}

static esp_err_t invert_color_my_pannel(esp_lcd_panel_t *panel, bool invert_color_data)
{
    return ESP_OK;
}

esp_err_t draw_my_pannel(esp_lcd_panel_t *, int x1, int y1, int x2, int y2, const void *color_data)
{
    LCDAccess lcd;

	if(x1 < _res_x && x2 >= 0 && y1 < _res_y && y2 >= 0) 
	{
        CS_EN cs_en;
		
		if(x1 < 0)	x1 = 0;
		if(y1 < 0)	y1 = 0;
		if(x2 > _res_x) x2 = _res_x ;
		if(y2 > _res_y) y2 = _res_y;

        --x2; --y2;
	
		_SetWriteArea(x1, y1, x2, y2);
		_WriteCommand(REG_WRITEMEM); //Write to RAM
	
		uint32_t total = (x2-x1+1)*(y2-y1+1);
        const uint8_t* c = (const uint8_t*)color_data; // <R><G><B> ?
#define R c[0]
#define G c[1]
#define B c[2]        
        while(total--)
   		{
   			_WriteData( ((G & 0x1C) << 3) | (B >> 3) ); 
   			_WriteData( (R & 0xF8) | ((G & 0xE0) >> 5) );
            c += 3;
   		}
#undef R
#undef G
#undef B
	}
    return ESP_OK;
}

esp_lcd_panel_handle_t esp_lcd_new_panel_my()
{
    return new esp_lcd_panel_t{
        .reset = DReset,
        .init = init_screen,
        .del = destroy_my_pannel,
        .draw_bitmap = draw_my_pannel,
        .mirror = mirror_my_pannel,
        .swap_xy = swap_my_pannel,
        .set_gap = set_gap_my_pannel,
        .invert_color = invert_color_my_pannel,
        .disp_on_off = DScreen
    };
}
#endif
